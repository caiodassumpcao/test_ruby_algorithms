# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `json_schemer` gem.
# Please instead update this file by running `bin/tapioca gem json_schemer`.

module JSONSchemer
  class << self
    def schema(schema, default_schema_class: T.unsafe(nil), **options); end
    def valid_schema?(schema, default_schema_class: T.unsafe(nil)); end
    def validate_schema(schema, default_schema_class: T.unsafe(nil)); end
  end
end

class JSONSchemer::CachedRefResolver < ::JSONSchemer::CachedResolver; end

class JSONSchemer::CachedResolver
  def initialize(&resolver); end

  def call(*args); end
end

JSONSchemer::DEFAULT_SCHEMA_CLASS = JSONSchemer::Schema::Draft7

class JSONSchemer::EcmaRegexp
  class << self
    def ruby_equivalent(pattern); end
  end
end

JSONSchemer::EcmaRegexp::RUBY_EQUIVALENTS = T.let(T.unsafe(nil), Hash)
class JSONSchemer::EcmaRegexp::Syntax < ::Regexp::Syntax::Base; end
JSONSchemer::EcmaRegexp::Syntax::SYNTAX = JSONSchemer::EcmaRegexp::Syntax

module JSONSchemer::Errors
  class << self
    def pretty(error); end
  end
end

JSONSchemer::FILE_URI_REF_RESOLVER = T.let(T.unsafe(nil), Proc)

module JSONSchemer::Format
  include ::JSONSchemer::Format::Email
  include ::JSONSchemer::Format::Hostname
  include ::JSONSchemer::Format::URITemplate

  def iri_escape(data); end
  def parse_uri_scheme(data); end
  def valid_date_time?(data); end
  def valid_ip?(data, family); end
  def valid_json?(data); end
  def valid_json_pointer?(data); end
  def valid_regex?(data); end
  def valid_relative_json_pointer?(data); end
  def valid_spec_format?(data, format); end
  def valid_uri?(data); end
  def valid_uri_reference?(data); end
end

JSONSchemer::Format::DATE_TIME_OFFSET_REGEX = T.let(T.unsafe(nil), Regexp)

module JSONSchemer::Format::Email
  def valid_email?(data); end
end

JSONSchemer::Format::Email::ADDRESS_LITERAL = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::ATOM = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::A_TEXT = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::DOT_STRING = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::EMAIL_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::Email::LOCAL_PART = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::MAILBOX = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::QUOTED_PAIR_SMTP = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::QUOTED_STRING = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::Q_CONTENT_SMTP = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::Q_TEXT_SMTP = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Email::UTF8_NON_ASCII = T.let(T.unsafe(nil), String)
JSONSchemer::Format::HOUR_24_REGEX = T.let(T.unsafe(nil), Regexp)

module JSONSchemer::Format::Hostname
  def valid_hostname?(data); end
end

JSONSchemer::Format::Hostname::ARABIC_EXTENDED_DIGITS_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::Hostname::ARABIC_INDIC_DIGITS_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::Hostname::CONTEXT_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::Hostname::EXCEPTIONS_DISALLOWED = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::EXCEPTIONS_PVALID = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::GREEK_LOWER_NUMERAL_SIGN = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::HEBREW_PUNCTUATION = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::HOSTNAME_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::Hostname::JOINING_TYPE_D_CHARACTER_CLASS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::JOINING_TYPE_L_CHARACTER_CLASS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::JOINING_TYPE_R_CHARACTER_CLASS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::JOINING_TYPE_T_CHARACTER_CLASS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::KATAKANA_MIDDLE_DOT_CONTEXT_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::Hostname::KATAKANA_MIDDLE_DOT_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::Hostname::LABEL_CHARACTER_CLASS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::LABEL_REGEX_STRING = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::LEADING_CHARACTER_CLASS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::LETTER_DIGITS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::MARKS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::MIDDLE_DOT = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::VIRAMA_CHARACTER_CLASS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::ZERO_WIDTH_NON_JOINER_JOINING_TYPE = T.let(T.unsafe(nil), String)
JSONSchemer::Format::Hostname::ZERO_WIDTH_VIRAMA = T.let(T.unsafe(nil), String)
JSONSchemer::Format::INVALID_QUERY_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::IP_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::JSON_POINTER_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::JSON_POINTER_REGEX_STRING = T.let(T.unsafe(nil), String)
JSONSchemer::Format::LEAP_SECOND_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::RELATIVE_JSON_POINTER_REGEX = T.let(T.unsafe(nil), Regexp)

module JSONSchemer::Format::URITemplate
  def valid_uri_template?(data); end
end

JSONSchemer::Format::URITemplate::EXPLODE = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::EXPRESSION = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::LITERALS = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::MAX_LENGTH = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::MODIFIER_LEVEL4 = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::OPERATOR = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::PCT_ENCODED = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::PREFIX = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::URI_TEMPLATE = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::URI_TEMPLATE_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Format::URITemplate::VARCHAR = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::VARIABLE_LIST = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::VARNAME = T.let(T.unsafe(nil), String)
JSONSchemer::Format::URITemplate::VARSPEC = T.let(T.unsafe(nil), String)
class JSONSchemer::InvalidEcmaRegexp < ::StandardError; end
class JSONSchemer::InvalidFileURI < ::StandardError; end
class JSONSchemer::InvalidRefResolution < ::StandardError; end
class JSONSchemer::InvalidRegexpResolution < ::StandardError; end
class JSONSchemer::InvalidSymbolKey < ::StandardError; end
JSONSchemer::SCHEMA_CLASS_BY_META_SCHEMA = T.let(T.unsafe(nil), Hash)
module JSONSchemer::Schema; end

class JSONSchemer::Schema::Base
  include ::JSONSchemer::Format::Email
  include ::JSONSchemer::Format::Hostname
  include ::JSONSchemer::Format::URITemplate
  include ::JSONSchemer::Format

  def initialize(schema, base_uri: T.unsafe(nil), format: T.unsafe(nil), insert_property_defaults: T.unsafe(nil), before_property_validation: T.unsafe(nil), after_property_validation: T.unsafe(nil), formats: T.unsafe(nil), keywords: T.unsafe(nil), ref_resolver: T.unsafe(nil), regexp_resolver: T.unsafe(nil)); end

  def valid?(data); end
  def valid_schema?; end
  def validate(data); end
  def validate_schema; end

  protected

  def ids; end
  def root; end
  def valid_instance?(instance); end
  def validate_instance(instance, &block); end

  private

  def child(schema, base_uri:); end
  def custom_format?(format); end
  def error(instance, type, details = T.unsafe(nil)); end
  def escape_json_pointer_token(token); end
  def format?; end
  def formats; end
  def id_keyword; end
  def join_uri(a, b); end
  def keywords; end
  def ref_resolver; end
  def regexp_resolver; end
  def resolve_ids(schema, ids = T.unsafe(nil), base_uri = T.unsafe(nil), pointer = T.unsafe(nil)); end
  def resolve_ref(uri); end
  def resolve_regexp(pattern); end
  def safe_strict_decode64(data); end
  def spec_format?(format); end
  def validate_array(instance, &block); end
  def validate_class(instance, &block); end
  def validate_custom_format(instance, custom_format); end
  def validate_exclusive_maximum(instance, exclusive_maximum, maximum); end
  def validate_exclusive_minimum(instance, exclusive_minimum, minimum); end
  def validate_integer(instance, &block); end
  def validate_number(instance, &block); end
  def validate_numeric(instance, &block); end
  def validate_object(instance, &block); end
  def validate_ref(instance, ref, &block); end
  def validate_string(instance, &block); end
  def validate_type(instance, type, &block); end

  class << self
    def draft_name; end
    def meta_schema; end
    def meta_schemer; end
  end
end

JSONSchemer::Schema::Base::BOOLEANS = T.let(T.unsafe(nil), Set)
JSONSchemer::Schema::Base::DEFAULT_REF_RESOLVER = T.let(T.unsafe(nil), Proc)
JSONSchemer::Schema::Base::ECMA_REGEXP_RESOLVER = T.let(T.unsafe(nil), Proc)
JSONSchemer::Schema::Base::ID_KEYWORD = T.let(T.unsafe(nil), String)
JSONSchemer::Schema::Base::INSERT_DEFAULT_PROPERTY = T.let(T.unsafe(nil), Proc)

class JSONSchemer::Schema::Base::Instance < ::Struct
  def after_property_validation; end
  def after_property_validation=(_); end
  def base_uri; end
  def base_uri=(_); end
  def before_property_validation; end
  def before_property_validation=(_); end
  def data; end
  def data=(_); end
  def data_pointer; end
  def data_pointer=(_); end
  def merge(data: T.unsafe(nil), data_pointer: T.unsafe(nil), schema: T.unsafe(nil), schema_pointer: T.unsafe(nil), base_uri: T.unsafe(nil), before_property_validation: T.unsafe(nil), after_property_validation: T.unsafe(nil)); end
  def schema; end
  def schema=(_); end
  def schema_pointer; end
  def schema_pointer=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

JSONSchemer::Schema::Base::JSON_POINTER_TOKEN_ESCAPE_CHARS = T.let(T.unsafe(nil), Hash)
JSONSchemer::Schema::Base::JSON_POINTER_TOKEN_ESCAPE_REGEX = T.let(T.unsafe(nil), Regexp)
JSONSchemer::Schema::Base::NET_HTTP_REF_RESOLVER = T.let(T.unsafe(nil), Proc)
JSONSchemer::Schema::Base::RUBY_REGEXP_RESOLVER = T.let(T.unsafe(nil), Proc)

class JSONSchemer::Schema::Draft4 < ::JSONSchemer::Schema::Base
  private

  def id_keyword; end
  def supported_format?(format); end
  def validate_exclusive_maximum(instance, exclusive_maximum, maximum); end
  def validate_exclusive_minimum(instance, exclusive_minimum, minimum); end
  def validate_integer(instance, &block); end
end

JSONSchemer::Schema::Draft4::ID_KEYWORD = T.let(T.unsafe(nil), String)
JSONSchemer::Schema::Draft4::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Set)

class JSONSchemer::Schema::Draft6 < ::JSONSchemer::Schema::Base
  private

  def supported_format?(format); end
end

JSONSchemer::Schema::Draft6::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Set)

class JSONSchemer::Schema::Draft7 < ::JSONSchemer::Schema::Base
  private

  def supported_format?(format); end
end

JSONSchemer::Schema::Draft7::SUPPORTED_FORMATS = T.let(T.unsafe(nil), Set)
class JSONSchemer::UnknownFormat < ::StandardError; end
class JSONSchemer::UnknownRef < ::StandardError; end
class JSONSchemer::UnsupportedMetaSchema < ::StandardError; end
JSONSchemer::VERSION = T.let(T.unsafe(nil), String)
JSONSchemer::WINDOWS_URI_PATH_REGEX = T.let(T.unsafe(nil), Regexp)
